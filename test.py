import unittest
import sys  # sys нужен для передачи argv в QApplication
from PyQt5 import QtWidgets
import diz

'''
Класс тестов (unnittest)
Создается класс произвольного имени, но
обязательно наследующий класс unittest.TestCase,
входящий в библиотеку unittest
Создаются тестовые случае, имена которых обязательно
начинаются с "test_"
В них вызывется метод assertEqual. Концептуально это выглядит так:
"Действительно ли ф-я, которя вызыается первым параметром
функции assertEqual, является тем, что мы указываем вторым 
параметром".
В данной задче важно понимать, что если число задано в 
10ной СС, то мы его передаём именно числом (int),
а в любой другой СС мы передаём СТРОКУ (string)
Результаты ф-ий тоже всегда строки
Что касается нашей функции с основной логикой (convert_base),
то параметры такие:
первый - само число, с которым мы работаем
второй - сс, в которую нужно перевести
третий - сс, в которой находится первичное число
'''
class TestSS(unittest.TestCase):

    def test_10t2(self):
        self.assertEqual(convert_base(64, 2, 10), '1000000')

    def test_2t10(self):
        self.assertEqual(convert_base('1000000', 10, 2), '64')

    def test_16t3(self):
        self.assertEqual(convert_base('25D', 3, 16), '211102')

    def test_101010t10(self):
        self.assertEqual(convert_base('101010', 10, 2), '42')

    def test_3553t2(self):
        self.assertEqual(convert_base('3553', 2, 16), '11010101010011')

    def test_101010010t8(self):
        self.assertEqual(convert_base('101010010', 8, 2), '522')

    def test_1000010t16(self):
        self.assertEqual(convert_base('1000010', 16, 2), '42')

    def test_25DA(self):
        self.assertEqual(convert_base('25DA', 10, 16), '9690')



class ExampleApp(QtWidgets.QMainWindow, diz.Ui_MainWindow):
    def __init__(self):
        # Это здесь нужно для доступа к переменным, методам
        # и т.д. в файле diz.py
        super().__init__()
        self.setupUi(self)  # Это нужно для инициализации нашего дизайна


'''
Вспомагательная ф-ия. Предназначена для
того, чтоб выдавать соответствующие 
числовые значения для букв
Если же число, переданное этой функции не яв-ся буквой,
то возвращается то же число, приведенное к int
Для простоты понимания объясню принцип названия этой ф-ии:
ifabc2dec: if abc 2(to) dec, что по моей логике можно
перевести как "если тут буква, то выведи десятичную циферку"
'''
def ifabc2dec(n):
    if n == 'A':
        return 10
    elif n == 'B':
        return 11
    elif n == 'C':
        return 12
    elif n == 'D':
        return 13
    elif n == 'E':
        return 14
    elif n == 'F':
        return 15
    else:
        return int(n)  


'''
А это перевод в 10-ную по схеме "Уважаемого" Горнера
Например:
25DA(16) = 2·16^3+5·16^2+13·16^1+1^0·1 = 969010
Параметры данной ф-ии:
num - само число, переданное в виде строки
base - СС, в которой передано число
debug - булевая переменная. В ней я сосредоточил такую логику:
если она True, то выводится дополнительная информация
по ходу вычеслений, если она False, то вывод будет более компактным.
'''
def gorner( num, base, debug ):

    if debug:
        print('Поступило: ', num)
        print('СС: ', base)

    b = ''
    ind = -1

    b = ifabc2dec(num[ind]) #int(num[ind])

    if debug:
        print('Индекс = ', ind)
        print('Текущее значение: ', num[ind])
        print('Промежуточный результат: ', b)
        print('=============')

    while (-ind) < len(num):
        ind -= 1
        b += int(ifabc2dec(num[ind])) * base**(-ind-1)

        if debug:
            # print('Индекс = ', ind)
            print('Текущее значение: ', (num[ind]))
            print('Текущей многочлен: ', int(ifabc2dec(num[ind])), ' * ' , base, '^', (-ind-1), ' = ', int(ifabc2dec(num[ind])) * base**(-ind-1))
            print('Промежуточный результат: ', b)
            print('-------------')
    
    if debug:
        print('Итог (Десятичный): ', b)
    return b


'''
Функция с основной логикой перевода. На входе:
1. Само число
2. СС, В КОТОРУЮ нужно перевести
3. СС, в которой НАХОДИТСЯ исходное число
ф-ия яв-ся рекурсией (в конце рекурсивный вывод),
по этому местами менять ничего не стоит
(проверено, все сломалось)
От сюда уже вызывается функция gorner, которая описана выше
Эта единственная функция, которую я скопировал из Интернета,
так что логику в конце функции я объяснить пока не могу(
Могу еще посидеть, если понадобится.
'''
def convert_base(num, to_base=10, from_base=10, debug=False):
    # first convert to decimal number
    if isinstance(num, str):
        # n = int(num, from_base) # преобразование к десятичному числу (сюда Горнера)
        n = gorner(num, from_base, debug) # А вот написанная мною схема горнера
    else:
        n = int(num)
    # now convert decimal to 'to_base' base
    alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"
    if n < to_base:
        return alphabet[n]
    else:
        return convert_base(n // to_base, to_base) + alphabet[n % to_base]


'''
Чисто вспомогательная ф-ия. Писал я её уже давно для личных нужд.
На вход принимает некое число и текст
Ф-ия просит ввести человека число от 1 до числа, которое полчает на входе
Тест, который мы передаем - текст перед вводом:
var = int(input(text))
Так же функция уже содержит зазиту от дурка, и не позволит выполнять
программу дальше, пока пользователь не введет коректное значение.
Пользуйся на здоровье, в свое время я долго сидел над её логикой)
'''
def inp(numb, text):
    #  Пока пользователь не сделает того, чего мы хотим
    while(True):
        try:
            var = int(input(text))

            count = 1

            while count != numb+1:
                if var == count:
                    print("\n")
                    return var
                count += 1

            print("\tОШИБКА: Такого варианта нет\n")

        except ValueError:          
            print("\tОШИБКА: Вы ввели недопустимое значение... \n")
    pass



'''
Главная функция - вызывается в начале программы.
Содержит меню, и реализован ввод данных пользователем.
Для большей модульности можно вырезать весь ввод и вставить 
в отдельную функцию, но это не обязательно)
Поясню на всякий еще и это:
break - выходит из цикла while
continue - проход цикла заканчивается, и сразу начинается новая
итерация
'''
def glavnaya():
    print("Добро пожаловать в программу!")

    debug = True

    # Цикл до тех пор, пока пользователь не выйдет из меню
    while True: 

        print("Главное меню\n")
        print("1. Начать выполнение программы")
        print("2. Переключить режим дебага (", debug, ")")
        print("3. Выход из программы")
        print("4. Запустить модуль тестов и выйти")

        # Число 4 указывает на количество разрешенных вариантов
        x = inp(4, "Выбор: ")

        # Реализация логики меню. Если х = 1, то просто продолжаем...
        if x == 2: # меняем значение debug на обратное
            if debug == True:
                debug = False
            else:
                debug = True
            continue
        elif x == 3: # break - выходит из цикла и завершает программу
            break
        elif x == 4:
            unittest.main() # вызывает модуль тестов
            continue

        # Сначала вводим исходную СС, и проверяем корректность
        try:
            si1 = int(input("Введите начальную СС: "))
            if si1 > 16 or si1 < 1:
                print("Ooops, такая СС у нас не предусмотрена)")
                continue
        # Елси не число (ошибка ValueError), то этот код:
        except ValueError:          
            print("\tОШИБКА: Вы ввели недопустимое значение... \n")
            continue

        # Вводим и проверяем корректность самого числа
        number = input("Введите исходно число: ")

        # Число ли это вообще? Думаю эта проверка излишне,
        # т.к. есть следующая проверка.
        # Можешь удалить этот блок, проверить как работает,
        # думаю все должно быть нормально.
        # для того чтоб ты не путался, я помечу этот 
        # блок решетками справа =)
        print("\tПроверка корректности...")     #
        if not testDurak(number):               #
            print("\tЧисло не корректно.")      #
            continue                            #
        print("\tЧисло корректно.\n")           #

        # Вторая проверка - на соответствие выбранной СС
        print("\tПроверка СС введенного числа...")
        iscorrect = lastproverka(si1, number) # Вызов ф-ии возвращает bool
        if not iscorrect:
            print("\tВведенное число не яв-ся числом выбранной СС")
            continue
        print("\tЧисло соответствует выбранной СС")

        # Вводим конечную СС, и проверяем её корректность
        # Все аналогично первичной СС, по этому сильно не коментирую
        try:
            si2 = int(input("Введите целевую СС: "))
            if si2 > 16 or si2 < 1:
                print("Ooops, такая СС у нас не предусмотрена)")
                continue
        except ValueError:          
            print("\tОШИБКА: Вы ввели недопустимое значение... \n")
            continue

        # Мы имеем все данные, все данные проверены, теперь вызываем 
        # ф-ию с основной логикой
        print("Результат подсчетов: ", convert_base(str(number), int(si2), int(si1), debug))

        print("=============\n")



'''
Сори за дебильное название - у меня поэтический кризис)
Роль этой функции - проверить, находится ли переданное число n
в СС ss
Ф-ия проверяет каждый символ в переданном числе,
и проверет его принадлежность к алфовиту.
Поясню подробнее...
alf = alf[:ss]
в этой строке мы обрезаем алфавит, в зависимости от переданной
СС. Например, если у нас 10-ная СС, то алфавит состоит из 10ти
символов. Если СС 3 - то алфовит из 3 чисел.
Дальше проверяем каждую цифру на принадлежность данному алфовиту
Если принадлежит - то прописываем об этом
Если НЕ пренадлежит, то тоже прописываем.
Возвращаем соответственно True или False
'''
def lastproverka(ss, n):
    alf = "0123456789ABCDEF"
    alf = alf[:ss]
    for bukva in n:
        proverka = False
        for buk in alf:
            if buk == bukva:
                proverka = True
                print("\t", bukva, "......YES")
        if not proverka:
            print("\t", bukva, "......NO")
            return False
    return True
        

'''
Тут функция выполняет практически то же самое, что и предыдущая.
Но эта функция предназначена для того, чтоб проверить, 
не ввел ли пользователь лишнего.
По правде говоря, эту ф-ию я написал первой, а lastproverka - следующей
и мне кажется, что та лучше, и что можно обойтись и без этой...
По сути можешь удалить её и все что с ней связано, по идее тоже должно
работать, но я пока не тестил - устал немного)
'''
def testDurak(number):
    check = True

    for t in number:
        if t == '0' or t == '1' or t == '2' or t == '3' or t == '4' or t == '5' or t == '6' or t == '7' or t == '8' or t == '9' or t == 'A' or t == 'B' or t == 'C' or t == 'D' or t == 'E' or t == 'F':
            print("\t", t, "......OK")
        else:
            print("\t", t, "......NO")
            print("Ooops, ты ввел недопустимый симвл)")
            check = False
            break

    if check:
        return True
    else:
        return False



def main():
    app = QtWidgets.QApplication(sys.argv)  # Новый экземпляр QApplication
    window = ExampleApp()  # Создаём объект класса ExampleApp
    window.show()  # Показываем окно
    app.exec_()  # и запускаем приложение


#############################
# Эта фигня запускает тесты #
#############################

if __name__ == '__main__':
    # unittest.main()
    # glavnaya()
    main()

'''
И так, это место, где начинает работать эта программа.
Если захочешь запустить программу в режиме предварительных тестов,
то закоментируй glavnaya(), и раскоменть # unittest.main()
Хотя только что буквально у меня появилась такая идея:
Можно в меню дописать еще один вариант (четвертый),
который предлагает запустить модуль тестов. Сейчас попробую...
Да, получилось, но прога почему-то завершается сразу. 
Если тебе это не нужно - просто удали)
Сейчас прокоменчу еще немного сам код, и скину тебе
''' 


